#+TITLE: クラスタ分析
#+SUBTITLE: 基本的な考え方と階層的方法
#+AUTHOR: 村田 昇
#+EMAIL: noboru.murata@gmail.com
#+DATE: 
# Time-stamp: <2024-12-12 10:59:03 mura>
#+STARTUP: hidestars content indent
:REVEAL:
#+SETUPFILE: "./reveal.js/local/mycourse.org"
# C-c C-x C-v でinlineを切り替え
# <m C-i でlatex block (math env用)
# C-c '
:END:

* COMMENT メモ
[[file:README.org::第10講]]

* COMMENT 講義の内容
:PROPERTIES:
:ID:       67BA72E8-0F1A-4886-8DC5-389510617DF1
:END:
# 早稲田大学
- *第1回 : 基本的な考え方と階層的方法*
- 第2回 : 非階層的方法と分析の評価

#+begin_src R :exports none :tangle no
  setwd("~/Desktop/lectures/mva/course")
#+end_src
#+begin_src R :exports none
  ### 第10講 資料
  library(conflicted)
  conflicts_prefer(
    dplyr::filter(),
    dplyr::select(),
    dplyr::lag(),
  )
  library(tidyverse)
  library(gt)
  library(GGally)
  library(ggfortify)
  library(cluster)
  library(ggdendro)
  #' 日本語表示・色の設定 (ggplot)
  theme_set(theme_gray(base_size = 16))
  if(Sys.info()[["sysname"]] == "Darwin") { # MacOSか確認
    if(length(grep("BIZUDPGothic", systemfonts::system_fonts()[["name"]]))>0) 
      theme_update(text = element_text(family = "BIZUDGothic-Regular"))
    else
      theme_update(text = element_text(family = "HiraMaruProN-W4"))}
  library(see)
  options(ggplot2.discrete.colour = function() scale_colour_material(),
          ggplot2.discrete.fill = function() scale_fill_material())
#+end_src

* 講義概要
:PROPERTIES:
:ID:       B7608B47-96BE-4EED-90B0-E82720BBAC51
:END:
# 東京大学
- *第1回 : 基本的な考え方と階層的方法*
- 第2回 : 非階層的方法と分析の評価

#+begin_src R :exports none :tangle no
  setwd("~/Desktop/lectures/u-tokyo/autumn/course")
  library(gt)
#+end_src
#+begin_src R :exports none 
  ### 第10講 サンプルコード
  library(conflicted)
  conflicts_prefer(
    dplyr::filter(),
    dplyr::select(),
    dplyr::lag(),
  )
  library(tidyverse)
  library(gt)
  library(ggfortify)
  library(GGally)
  library(cluster)
  library(ggdendro)
#+end_src


* クラスタ分析の例
** 実データによる例
:PROPERTIES:
:END:
# 東京大学 (再)
- 総務省統計局より取得した都道府県別の社会生活統計指標の一部
  - 総務省 [[https://www.e-stat.go.jp/SG1/estat/List.do?bid=000001083999&cycode=0]]
  - データ [[https://noboru-murata.github.io/statistical-data-analysis2/data/data06.zip]]
    #+begin_example
    Pref   : 都道府県名
    Forest : 森林面積割合 (%) 2014年
    Agri   : 就業者１人当たり農業産出額(販売農家）(万円) 2014年
    Ratio  : 全国総人口に占める人口割合 (%) 2015年
    Land   : 土地生産性（耕地面積１ヘクタール当たり）(万円) 2014年
    Goods  : 商業年間商品販売額［卸売業＋小売業］（事業所当たり）(百万円) 2013年
    Area   : 地方区分
    #+end_example

** COMMENT 実データによる例
:PROPERTIES:
:END:
# 早稲田大学 (再)
- 総務省統計局より取得した都道府県別の社会生活統計指標の一部
  - 総務省 [[https://www.e-stat.go.jp/SG1/estat/List.do?bid=000001083999&cycode=0]]
  - データ https://noboru-murata.github.io/multivariate-analysis/data/japan_social.csv
    #+begin_example
    Pref   : 都道府県名
    Forest : 森林面積割合 (%) 2014年
    Agri   : 就業者１人当たり農業産出額(販売農家）(万円) 2014年
    Ratio  : 全国総人口に占める人口割合 (%) 2015年
    Land   : 土地生産性（耕地面積１ヘクタール当たり）(万円) 2014年
    Goods  : 商業年間商品販売額［卸売業＋小売業］（事業所当たり）(百万円) 2013年
    Area   : 地方区分
    #+end_example
  
** データの概要
:PROPERTIES:
:ID:       B6A543CF-F3D8-423A-9BD2-93B6021BD821
:END:
#+begin_src R :exports none
  #' @exercise 実データによるクラスタ分析の例
  #' 以下の例で用いる分析のための関数の詳細は今回・次回で解説
  #' データの読み込み
  js_data <- read_csv("data/japan_social.csv") |>
    mutate(Area = as_factor(Area))
#+end_src
#+begin_src R :eval no :exports none
  js_data |> View() # 左上ペインに表として表示
#+end_src
#+begin_src R :exports results :results output html :tangle no
  #' データの表示(reveal用)
  js_data |>
    slice(1:15) |>
    gt() |>
    as_raw_html()
#+end_src
#+begin_src R :exports results :results value scalar latex :tangle no
  #' データの表示(latex用)
  js_data |>
    gt() |>
    tab_options(table.font.size = 9) |>
    as_latex() |> as.character()
#+end_src

# #+reveal: split
# - データの内容
#   #+html: <font size=5>
#   #+begin_src R :exports results :results output html :tangle no
#     #' データの表示(reveal用)
#     library(gt)
#     js_data |> slice(1:15) |> 
#       gt() |> as_raw_html()
#   #+end_src
#   #+html: </font>
#   #+begin_src R :exports results :results output latex :tangle no
#     #' データの表示(latex用)
#     js_data |> slice(1:15) |> 
#       gt() |> as_latex()
#   #+end_src

** 分析の目的
:PROPERTIES:
:ID:       13EA22C7-AB69-443F-90F8-DEDD858394D4
:END:
#+begin_src R :file figs/10_pairs.png :exports results :results graphics
  #' データの視覚化
  js_data |> # 散布図．いくつかの変数は相関強いことがわかる
    ggpairs(columns = 2:6,
            upper = list(continuous = "cor"),
            diag = list(continuous = wrap("densityDiag", alpha = 0.4),
                        mapping = aes(colour = Area)),
            lower = list(continuous = wrap("points", size = 1),
                         mapping = aes(colour = Area)))
    #+end_src
#+caption: 散布図
#+name: fig:10_pairs
#+attr_html: height 100%
#+attr_latex: :width 0.6\linewidth
[[file:figs/10_pairs.png]]

#+reveal: split
#+begin_src R :file figs/10_pcaplot.png :exports results :results graphics
  js_data |> 
    column_to_rownames(var = "Pref") |> 
    select(where(is.double)) |> 
    pam(1) |> # クラスタリングしない
    autoplot(data = js_data,
             colour = "Area",
             label = TRUE,
             label.repel = TRUE,
             label.show.legend = FALSE) +
    theme(legend.position = c(.9,.3))
#+end_src
#+caption: 主成分得点による散布図
#+name: fig:10_pcaplot
#+attr_html: height 100%
#+attr_latex: :width 0.6\linewidth
[[file:figs/10_pcaplot.png]]

#+reveal: split
#+begin_src R :file figs/10_clusplot.png :exports results :results graphics
  #' クラスタ分析
  js_data |> 
    column_to_rownames(var = "Pref") |> 
    select(where(is.double)) |> 
    pam(6) |>
    autoplot(frame = TRUE,
             frame.type = "convex",
             label = TRUE,
             label.repel = TRUE,
             label.show.legend = FALSE) +
    theme(legend.position = c(.9,.2))
#+end_src
#+caption: 散布図上のクラスタ構造 (クラスタ分析の概念図)
#+name: fig:10_clusplot
#+attr_html: height 100%
#+attr_latex: :width 0.6\linewidth
[[file:figs/10_clusplot.png]]


* クラスタ分析の考え方
** クラスタ分析
- クラスタ分析 (*cluster analysis*) の目的
  #+begin_quote
  個体の間に隠れている
  *集まり=クラスタ*
  を個体間の"距離"にもとづいて発見する方法
  #+end_quote
- 個体間の類似度・距離(非類似度)を定義
  - 同じクラスタに属する個体どうしは似通った性質
  - 異なるクラスタに属する個体どうしは異なる性質
- さらなるデータ解析やデータの可視化に利用
- 教師なし学習の代表的な手法の一つ

** クラスタ分析の考え方
- 階層的方法
  - データ点およびクラスタの間に *距離* を定義
  - 距離に基づいてグループ化
    - 近いものから順にクラスタを *凝集*
    - 近いものが同じクラスタに残るように *分割*
- 非階層的方法
  - クラスタの数を事前に指定
  - クラスタの *集まりの良さ* を評価する損失関数を定義
  - 損失関数を最小化するようにクラスタを形成


* 階層的方法
** 凝集的クラスタリング
1. データ・クラスタ間の距離を定義する
   - データ点とデータ点の距離
   - クラスタとクラスタの距離
2. データ点およびクラスタ間の距離を求める
3. 最も近い2つを統合し新たなクラスタを形成する
   - データ点とデータ点
   - データ点とクラスタ
   - クラスタとクラスタ
4. クラスタ数が1つになるまで2-3の手続きを繰り返す

** 事例
:PROPERTIES:
:ID:       47ACA170-C74E-4F57-8282-4A96BAD56F80
:END:
- [[color:green][社会生活統計指標の一部(関東地方)]]
  #+begin_src R :exports none
    js_data <- bind_cols(
      read_csv(file="data/japan_social.csv"),
      read_csv(file="data/prefecture.csv"))
    js_kanto <- js_data |> 
      slice(8:14) |>
      select(jp,2:6) |>
      set_names(c("都道府県名","森林面積割合","農業産出額","人口割合","土地生産性","商品販売額"))
  #+end_src
  #+begin_src R :eval no :exports none
    js_kanto |> View() # 左上ペインに表として表示
  #+end_src
  #+begin_src R :exports results :results output html :tangle no
    #' データの表示(reveal用)
    js_kanto |>
      gt() |>
      as_raw_html()
  #+end_src
  #+begin_src R :exports results :results value scalar latex :tangle no
    #' データの表示(latex用)
    js_kanto |>
      gt() |>
      tab_options(table.font.size = 9) |>
      as_latex() |> as.character()
  #+end_src

#+reveal: split
#+begin_src R :file figs/10_hclst0.png :exports results :results graphics :tangle no
  library(cluster)
  myPlot <- function(k) {
    if(Sys.info()["sysname"]=="Darwin"){par(family="HiraginoSans-W4")}
    tmpa <- js_data |>
      slice(8:14) |>
      select(2:6,jp) |>
      column_to_rownames(var = "jp")
    # tmpa <- js_data[8:14,]
    tmpb <- list(c(1,2,3,4,1,6,7),
                 c(1,2,3,1,1,6,7),
                 c(1,2,2,1,1,6,7),
                 c(1,2,2,1,1,6,1),
                 c(1,1,1,1,1,6,1),
                 c(1,1,1,1,1,1,1))
    clusplot(x=tmpa,
             clus=c(1,2,3,4,5,6,7),
             diss=FALSE,
             stand=TRUE, lines=0, labels=3, lwd=2,
             main=NULL, sub=NULL, cex=1, cex.txt=1.5,
             xlim=c(-2.5,2.5), ylim=c(-2.5,2.5),
             xaxt="n", yaxt="n", ann=FALSE,
             col.p="blue", col.txt="darkgray", col.clus="white", shade=FALSE)
    if(k>0) {
      for(i in 1:k) {
        clusplot(x=tmpa,
                 clus=tmpb[[i]],
                 diss=FALSE, cex=0.2, 
                 stand=TRUE, add=TRUE, span=FALSE,
                 lines=0, lwd=4, col.p="blue", col.clus="orange")
      }
    }
  }
  myPlot(0)
#+end_src

#+CAPTION: 凝集的クラスタリング
#+NAME: fig:10_hclst0
#+ATTR_HTML: height 100%
#+ATTR_LATEX: :width 0.6\linewidth
[[file:figs/10_hclst0.png]]

#+reveal: split
#+begin_src R :file figs/10_hclst1.png :exports results :results graphics :tangle no
  myPlot(1)
#+end_src

#+CAPTION: クラスタリングの手続き (その1)
#+NAME: fig:10_hclst1
#+ATTR_HTML: height 100%
#+ATTR_LATEX: :width 0.6\linewidth
[[file:figs/10_hclst1.png]]

#+reveal: split
#+begin_src R :file figs/10_hclst2.png :exports results :results graphics :tangle no
  myPlot(2)
#+end_src

#+CAPTION: クラスタリングの手続き (その2)
#+NAME: fig:10_hclst2
#+ATTR_HTML: height 100%
#+ATTR_LATEX: :width 0.6\linewidth
[[file:figs/10_hclst2.png]]

#+reveal: split
#+begin_src R :file figs/10_hclst3.png :exports results :results graphics :tangle no
  myPlot(3)
#+end_src

#+CAPTION: クラスタリングの手続き (その3)
#+NAME: fig:10_hclst3
#+ATTR_HTML: height 100%
#+ATTR_LATEX: :width 0.6\linewidth
[[file:figs/10_hclst3.png]]

#+reveal: split
#+begin_src R :file figs/10_hclst4.png :exports results :results graphics :tangle no
  myPlot(4)
#+end_src

#+CAPTION: クラスタリングの手続き (その4)
#+NAME: fig:10_hclst4
#+ATTR_HTML: height 100%
#+ATTR_LATEX: :width 0.6\linewidth
[[file:figs/10_hclst4.png]]

   
#+reveal: split
#+begin_src R :file figs/10_hclst5.png :exports results :results graphics :tangle no
  myPlot(5)
#+end_src
   
#+CAPTION: クラスタリングの手続き (その5)
#+NAME: fig:10_hclst5
#+ATTR_HTML: height 100%
#+ATTR_LATEX: :width 0.6\linewidth
[[file:figs/10_hclst5.png]]

   
#+reveal: split
#+begin_src R :file figs/10_hclst6.png :exports results :results graphics :tangle no
  myPlot(6)
#+end_src
   
#+CAPTION: クラスタリングの手続き (その6)
#+NAME: fig:10_hclst6
#+ATTR_HTML: height 100%
#+ATTR_LATEX: :width 0.6\linewidth
[[file:figs/10_hclst6.png]]

#+reveal: split
#+begin_src R :file figs/10_dendro.png :exports results :results graphics :tangle no
  if(Sys.info()["sysname"]=="Darwin"){par(family="HiraginoSans-W4")}
  js_data |>
    slice(8:14) |>
    select(2:6,jp) |>
    column_to_rownames(var = "jp") |>
    scale() |>
    agnes() |>
    plot(which.plots=2, main="",sub="",xlab="")
#+end_src
   
#+CAPTION: デンドログラムによるクラスタ構造の表示
#+NAME: fig:10_dendro
#+ATTR_HTML: height 100%
#+ATTR_LATEX: :width 0.6\linewidth
[[file:figs/10_dendro.png]]

   
* データ間の距離
** データ間の距離
- データ : 変数の値を成分としてもつベクトル
  #+begin_quote
  \begin{equation}
    \boldsymbol{x}=(x_{1},\dotsc,x_{d})^{\mathsf{T}},
    \boldsymbol{y}=(y_{1},\dotsc,y_{d})^{\mathsf{T}}\in\mathbb{R}^{d}
  \end{equation}
  #+end_quote
- 距離 : \(d(\boldsymbol{x},\boldsymbol{y})\)
- 代表的なデータ間の距離
  - Euclid 距離 (ユークリッド ; Euclidean distance)
  - Manhattan 距離 (マンハッタン ; Manhattan distance)
  - Minkowski 距離 (ミンコフスキー ; Minkowski distance)

** Euclid 距離
- 最も一般的な距離
- 各成分の差の2乗和の平方根 (2ノルム)
  #+begin_quote
  \begin{equation}
    d(\boldsymbol{x},\boldsymbol{y})
    =\sqrt{(x_{1}-y_{1})^{2}+\dotsb+(x_{d}-y_{d})^{2}}
  \end{equation}
  #+end_quote

** Manhattan 距離
- 後述する Minkowski 距離の \(p=1\) の場合
- 格子状に引かれた路に沿って移動するときの距離
  #+begin_quote
  \begin{equation}
    d(\boldsymbol{x},\boldsymbol{y})
    =|x_{1}-y_{1}|+\dotsb+|x_{d}-y_{d}|
  \end{equation}
  #+end_quote

** Minkowski 距離
- Euclid 距離を \(p\) 乗に一般化した距離
- 各成分の差の \(p\) 乗和の \(p\) 乗根(\(p\)-ノルム)
  #+begin_quote
  \begin{equation}
    d(\boldsymbol{x},\boldsymbol{y})
    =\bigl\{|x_{1}-y_{1}|^{p}+\dotsb+|x_{d}-y_{d}|^{p}\bigr\}^{1/p}
  \end{equation}
  #+end_quote

** その他の距離
- 類似度や乖離度などデータ間に自然に定義されるものを用いることは可能
  - 語句の共起 (同一文書に現れる頻度・確率)
  - 会社間の取引量 (売上高などで正規化が必要)
- 擬似的な距離でもアルゴリズムは動く


* COMMENT 演習
:PROPERTIES:
:reveal_background: #fef4f4
:END:
# 早稲田大学
** 問題
:PROPERTIES:
:reveal_background: #fef4f4
:END:
- 以下の問に答えなさい
  - 距離の定義を述べなさい
  - Minkowski 距離において
    \(p\to\infty\)
    とするとどのような距離となるか答えなさい
    #+begin_quote
    \begin{equation}
      d(\boldsymbol{x},\boldsymbol{y})
      =\bigl\{|x_{1}-y_{1}|^{p}+\dotsb+|x_{d}-y_{d}|^{p}\bigr\}^{1/p}
    \end{equation}
    #+end_quote

** 解答例
:PROPERTIES:
:reveal_background: #fef4f4
:END:
- 2変数の実数値関数で以下の3つの条件を満たす
  #+begin_quote
  - 非退化性
    \begin{equation}
      x=y \Leftrightarrow d(x,y)=0
    \end{equation}
  - 対称性
    \begin{equation}
      d(x,y)=d(y,x)
    \end{equation}
  - 劣加法性 (三角不等式の成立)
    \begin{equation}
      d(x,y)+d(y,z)\ge d(x,z)
    \end{equation}
  #+end_quote

#+reveal: split
- 非負性 \(d(x,y)\ge 0\) は3つの条件から自然に導かれる
  #+begin_quote
  \begin{align}
    &d(x,y)+d(y,x)\ge d(x,x)&&\text{(劣加法性)}\\
    &d(x,y)+d(x,y)\ge d(x,x)&&\text{(対称性)}\\
    &2d(x,y)\ge 0&&\text{(非退化性)}\\
    &d(x,y)\ge 0
  \end{align}
  #+end_quote

#+reveal: split
- 最大の要素に着目して計算すればよい
  #+begin_quote
  \begin{align}
    \lim_{p\to\infty} d(\boldsymbol{x},\boldsymbol{y})
    &=
      \lim_{p\to\infty} 
      \bigl\{|x_{1}-y_{1}|^{p}+\dotsb+|x_{d}-y_{d}|^{p}\bigr\}^{1/p}\\
    &=
      \lim_{p\to\infty} \max_{k}|x_{k}-y_{k}|
      \left\{
      \left(\frac{|x_{1}-y_{1}|}{\max_{k}|x_{k}-y_{k}|}
      \right)^{p}
      \right.\\
    &\qquad
      +\dotsb
      \left.
      \left(\frac{|x_{d}-y_{d}|}{\max_{k}|x_{k}-y_{k}|}
      \right)^{p}
      \right\}^{1/p}\\
    &=
      \max_{k}|x_{k}-y_{k}|
      \lim_{p\to\infty} 
      \text{(1以上の有限値)}^{1/p}\\
    &=
      \max_{k}|x_{k}-y_{k}|
  \end{align}
  #+end_quote
  - Chebyshev 距離(最大距離，チェス盤距離)という
    # Čebyšëv

#+reveal: split
- \(p\to-\infty\) の場合は以下となることを確認せよ
  #+begin_quote
  \begin{equation}
    \lim_{p\to-\infty} d(\boldsymbol{x},\boldsymbol{y})
    =\min_{k}|x_{k}-y_{k}|
  \end{equation}
  #+end_quote
  

* 実習
:PROPERTIES:
:reveal_background: #fef4f4
:END:
# 東京大学
** R : クラスタ分析
:PROPERTIES:
:reveal_background: #fef4f4
:ID:       122E64CD-BC8C-4ECB-96C9-29443B23443D
:END:
- 関連するパッケージ
  - *stats* : base R の基本的な統計に関するパッケージ
    - 関数 ~dist()~, ~hclust~, ~kmeans()~ など
    - 標準でインストールされている
  - *cluster* : Kaufman and Rousseeuw (1990) にもとづくパッケージ
    - 関数 ~daisy()~, ~agnes()~, ~pam()~ など
    - 標準でインストールされている
  - *ggfortify* : ggplotによる描画を補助するパッケージ
    - 関数 ~autoplot()~ など
    - 既に導入済み(回帰，主成分，判別分析でも利用)
  - *ggdendro* : ggplotによるデンドログラム描画のパッケージ
    #+begin_src R :exports code :tangle no
      #' 最初に一度だけ以下のいずれかを実行しておく
      #'  - Package タブから ggdendro をインストール
      #'  - コンソール上で次のコマンドを実行 'install.packages("ggdendro")'
    #+end_src

** COMMENT R : 関数 ~dist()~ 
:PROPERTIES:
:reveal_background: #fef4f4
:ID:       AE111138-526B-4567-9F1F-E4DC65CC6D7E
:END:
- データフレームを用いた基本的な計算方法
  #+begin_src R :eval no
    ### 距離の計算，返値は dist class (特殊なベクトル)
    dst <- dist(x, method = "euclidean", diag = FALSE, upper = FALSE)
    ## x: データフレーム
    ## method: 距離 (標準はユークリッド距離，他は"manhattan","minkowski"など)
    ## diag: 対角成分を持たせるか 
    ## upper: 上三角成分を持たせるか (標準は下三角成分のみ)

    ### 距離行列全体の表示
    dst # または print(dst)

    ### 特定の成分の取得
    as.matrix(dst)[i，j]
    ## i,j: 行・列の指定 (数値ベクトル，データフレームの行名)
  #+end_src

** R : データ間の距離の計算
:PROPERTIES:
:reveal_background: #fef4f4
:ID:       F308DB23-6E0F-48FA-8845-55C7FC617ACC
:END:
- 関数 ~stats::dist()~ 
  #+begin_src R :eval no :tangle no
    dist(x, method = "euclidean", diag = FALSE, upper = FALSE, p = 2)
    #' x: データフレーム
    #' method: 距離 (標準はユークリッド距離，他は"manhattan","minkowski"など)
    #' diag: 対角成分を持たせるか 
    #' upper: 上三角成分を持たせるか (標準は下三角成分のみ)
    #' 返値は dist class
  #+end_src
- 関数 ~cluster::daisy()~ 
  #+begin_src R :eval no :tangle no
    daisy(x, metric = c("euclidean", "manhattan", "gower"),
          stand = FALSE, type = list(), weights = rep.int(1, p),
          warnBin = warnType, warnAsym = warnType, warnConst = warnType,
          warnType = TRUE)
    #' x: データフレーム
    #' metric: 距離 (標準はユークリッド距離，他は"manhattan"など)
    #' stand: 正規化(平均と絶対偏差の平均による)の有無
    #' 返値は dissimilarity class
  #+end_src

** 練習問題
:PROPERTIES:
:reveal_background: #fef4f4
:ID:       D22E87E3-E968-4F93-9ED3-CFA9473F2463
:END:
- 都道府県別の社会生活統計指標を用いて以下を確認しなさい
  #+begin_src R :eval no :tangle no
    #' データの読み込み方の例
    js_df <- read_csv("data/japan_social.csv") |>
      column_to_rownames(var = "Pref") |> # 'Pref'を行名に変換
      select(-Area) # 地方名は除く
  #+end_src
  - 正規化せずにユークリッド距離とマンハッタン距離の計算を行いなさい
  - 正規化して上記と同様の計算を行いなさい 
  - 関東の都県同士の距離を表示しなさい (daisyによる正規化を用いなさい)
  - 大阪と四国の間の距離を表示しなさい
  - ユークリッド距離とマンハッタン距離の散布図を描き比較しなさい
    
** COMMENT 解答例
#+begin_src R :exports none
  #' ---------------------------------------------------------------------------
  #' @practice 距離の計算
#+end_src
#+begin_src R :eval no :exports none
  #' データの読み込み
  js_data <- read_csv("data/japan_social.csv") |>
    mutate(Area = as_factor(Area))
  js_df <- js_data |>
    column_to_rownames(var = "Pref") |> # 'Pref'を行名に変換
    select(-Area) # 距離計算に不要な地方名は除く
  #' @notes
  #' 'js_data' のまま扱うこともできるが，距離・類似度を計算する関数は
  #' 'js_df' の形式(base::data.frame())を想定しているため用意しておく

  #' ユークリッド距離とマンハッタン距離の計算
  js_dist_euc <- dist(js_df, method = "euclidean")
  js_dist_man <- dist(js_df, method = "manhattan")
  js_daisy_euc <- daisy(js_df, metric = "euclidean")
  js_daisy_man <- daisy(js_df, metric = "manhattan")
  #' 両者が同じことを確認
  as.matrix(js_dist_euc)[1:5,1:5]
  as.matrix(js_daisy_euc)[1:5,1:5]

  #' 正規化したユークリッド距離とマンハッタン距離の計算
  js_dist_euc <- dist(scale(js_df), method = "euclidean")
  js_dist_man <- dist(scale(js_df), method = "manhattan")
  js_daisy_euc <- daisy(js_df, metric = "euclidean", stand = TRUE)
  js_daisy_man <- daisy(js_df, metric = "manhattan", stand = TRUE)
  #' 正規化の方法が異なることに注意
  as.matrix(js_dist_man)[10:15,10:15]
  as.matrix(js_daisy_man)[10:15,10:15]

  #' 以下 daisy による正規化を用いる
  #' 関東の都県同士の距離を表示しなさい
  glimpse(js_daisy_euc) # 距離行列のもつ情報を見る
  attr(js_daisy_euc, "Labels") # 県名を確認 ('attributes(js_daisy_euc)$Labels' でも良い)
  as.matrix(js_daisy_euc)[8:14, 8:14]
  as.matrix(js_daisy_man)[8:14, 8:14]
  #' dist/dissimilarity オブジェクトは距離以外の様々な属性 (attributes) を持つ
  #' glimpse(obj) : オブジェクトの構造(structure)を見る(関数strでも良い)
  #' attributes(obj) : 属性を表示(変更)する
  #' attr(obj,属性名) : 特定の属性を表示(変更)する

  #' 大阪と四国の間の距離
  as.matrix(js_daisy_euc)[27, 36:39, drop = FALSE] # 行列として表示
  as.matrix(js_daisy_man)["Osaka", # 1行なので標準ではベクトルとして扱われる
                          c("Tokushima","Kagawa","Ehime","Kochi")]

  #' ユークリッド距離とマンハッタン距離の散布図
  p <- tibble( # 列名に特殊な文字(空白など)を含む場合は `` で囲む
    `Euclid dist.` = as.vector(js_daisy_euc),
    `Manhattan dist.` = as.vector(js_daisy_man)) |>
    ggplot(aes(x = `Euclid dist.`, y = `Manhattan dist.`)) +
    geom_point(colour = "blue")

  p + geom_abline(slope = 1, intercept = 0, colour = "red") # 基準線を付けて表示
  p + xlim(0,3) + ylim(0,3) # 原点近傍のみ表示
  #' いくつか順序が入れ替わっていることがわかる
#+end_src
#+begin_src R :exports none
  #' ---------------------------------------------------------------------------
#+end_src


* クラスタ間の距離   
** クラスタ間の距離
- クラスタ : いくつかのデータ点からなる集合
  #+begin_quote
  \begin{equation}
    C_{a}=\left\{\boldsymbol{x}_{i}|i\in\Lambda_{a}\right\},\;
    C_{b}=\left\{\boldsymbol{x}_{j}|j\in\Lambda_{b}\right\},\quad
    C_{a}\cap C_{b}=\emptyset
  \end{equation}
  #+end_quote
- 2つのクラスタ間の距離 : \(D(C_{a},C_{b})\)
  - データ点の距離から陽に定義する方法
  - クラスタの統合にもとづき再帰的に定義する方法
- 代表的なクラスタ間の距離
  - 最短距離法 (単連結法 ; single linkage method)
  - 最長距離法 (完全連結法 ; complete linkage method)
  - 群平均法 (average linkage method)

** 最短距離法
- 最も近い対象間の距離を用いる方法
  #+begin_quote
  \begin{equation}
    D(C_{a},C_{b})
    =\min_{\boldsymbol{x}\in C_{a},\;\boldsymbol{y}\in C_{b}} d(\boldsymbol{x},\boldsymbol{y})
  \end{equation}
  #+end_quote
- 統合前後のクラスタ間の関係
  #+begin_quote
  \begin{equation}
    D(C_{a}+ C_{b}, C_{c})
    =\min\bigl\{D(C_{a},C_{c}), D(C_{b},C_{c})\bigr\}
    % =\min\left\{D(C_{a},C_{c}), D(C_{b},C_{c})\right\}
  \end{equation}
  #+end_quote

** 最長距離法
- 最も遠い対象間の距離を用いる方法
  #+begin_quote
  \begin{equation}
    D(C_{a},C_{b})
    =\max_{\boldsymbol{x}\in C_{a},\;\boldsymbol{y}\in C_{b}} d(\boldsymbol{x},\boldsymbol{y})
  \end{equation}
  #+end_quote
- 統合前後のクラスタ間の関係
  #+begin_quote
  \begin{equation}
    D(C_{a}+ C_{b}, C_{c})
    =\max\bigl\{D(C_{a},C_{c}), D(C_{b},C_{c})\bigr\}
    % =\max\left\{D(C_{a},C_{c}), D(C_{b},C_{c})\right\}
  \end{equation}
  #+end_quote

** 群平均法
- 全ての対象間の平均距離を用いる方法
  #+begin_quote
  \begin{equation}
    D(C_{a},C_{b})
    =\frac{1}{|C_{a}||C_{b}|}
    \sum_{\boldsymbol{x}\in C_{a},\;\boldsymbol{y}\in C_{b}} d(\boldsymbol{x},\boldsymbol{y})
  \end{equation}
  #+end_quote
  - ただし \(|C_{a}|\), \(|C_{b}|\) はクラスタ内の要素の数を表す
- 統合前後のクラスタ間の関係
  #+begin_quote
  \begin{equation}
    D(C_{a}+ C_{b}, C_{c})
    =\frac{|C_{a}|D(C_{a},C_{c})+|C_{b}|D(C_{b},C_{c})}{|C_{a}|+|C_{b}|}
  \end{equation}
  #+end_quote

** 距離計算に関する注意
- データの性質に応じて距離は適宜使い分ける
  - データ間の距離の選択
  - クラスタ間の距離の選択
- 変数の正規化は必要に応じて行う
  - 物理的な意味合いを積極的に利用する場合はそのまま
  - 単位の取り方などによる分析の不確定性を避ける場合は平均0，分散1に正規化
- データの性質を鑑みて適切に前処理


* COMMENT 演習
:PROPERTIES:
:reveal_background: #fef4f4
:END:
# 早稲田大学
** 問題
:PROPERTIES:
:reveal_background: #fef4f4
:END:
- 以下の問に答えなさい
  - 群平均法におけるクラスタの距離の定義
    #+begin_quote
    \begin{equation}
      D(C_{a},C_{b})
      =\frac{1}{|C_{a}||C_{b}|}
      \sum_{\boldsymbol{x}\in C_{a},\;\boldsymbol{y}\in C_{b}} d(\boldsymbol{x},\boldsymbol{y})
    \end{equation}
    #+end_quote
    から統合前後のクラスタの距離の関係
    #+begin_quote
    \begin{equation}
      D(C_{a}+ C_{b}, C_{c})
      =\frac{|C_{a}|D(C_{a},C_{c})+|C_{b}|D(C_{b},C_{c})}{|C_{a}|+|C_{b}|}
    \end{equation}
    #+end_quote
    を導け

** 解答例
:PROPERTIES:
:reveal_background: #fef4f4
:END:
- 定義に従って計算する
  #+begin_quote
  \begin{align}
    D(C_{a}+C_{b}, C_{c})
    &=
      \frac{1}{|C_{a}+C_{b}||C_{c}|}
      \sum_{\boldsymbol{x}\in C_{a}+C_{b},\;\boldsymbol{y}\in C_{c}}
      d(\boldsymbol{x},\boldsymbol{y})\\
    &=
      \frac{1}{|C_{a}+C_{b}||C_{c}|}
      \sum_{\boldsymbol{x}\in C_{a},\;\boldsymbol{y}\in C_{c}}
      d(\boldsymbol{x},\boldsymbol{y})\\
    &\qquad+
      \frac{1}{|C_{a}+C_{b}||C_{c}|}
      \sum_{\boldsymbol{x}\in C_{b},\;\boldsymbol{y}\in C_{c}}
      d(\boldsymbol{x},\boldsymbol{y})\\
  \end{align}
  #+end_quote

#+reveal: split
- (続き)
  #+begin_quote
  \begin{align}
    &=
      \frac{|C_{a}||C_{c}|}{|C_{a}+C_{b}||C_{c}|}
      \frac{1}{|C_{a}||C_{c}|}
      \sum_{\boldsymbol{x}\in C_{a},\;\boldsymbol{y}\in C_{c}}
      d(\boldsymbol{x},\boldsymbol{y})\\
    &\qquad+
      \frac{|C_{b}||C_{c}|}{|C_{a}+C_{b}||C_{c}|}
      \frac{1}{|C_{b}||C_{c}|}
      \sum_{\boldsymbol{x}\in C_{b},\;\boldsymbol{y}\in C_{c}}
      d(\boldsymbol{x},\boldsymbol{y})\\
    &=
      \frac{|C_{a}||C_{c}|}{|C_{a}+C_{b}||C_{c}|}
      D(C_{a}, C_{c})
      +
      \frac{|C_{b}||C_{c}|}{|C_{a}+C_{b}||C_{c}|}
      D(C_{b}, C_{c})\\
    &=
      \frac{|C_{a}|D(C_{a}, C_{c})+|C_{b}|D(C_{b}, C_{c})}
      {|C_{a}|+|C_{b}|}
  \end{align}
  #+end_quote


* 実習
:PROPERTIES:
:reveal_background: #fef4f4
:END:
# 東京大学
** R : 階層的クラスタリング
:PROPERTIES:
:reveal_background: #fef4f4
:ID:       F217C7F8-45C2-48ED-9642-0BFA62F9E9B9
:END:
- 関数 ~stats::hclust()~ 
  #+begin_src R :eval no :tangle no
    hclust(d, method = "complete", members = NULL)
    #' d: 距離行列
    #' method: 分析法 (標準は最長距離法，他は"single","average"など)
  #+end_src
- 分析のための補助的な関数
  #+begin_src R :eval no :tangle no
    #' stats::cutree() - デンドログラムに基づくクラスタの分割 
    cutree(tree, k = NULL, h = NULL)
    #' tree: stats::hclust() の返値
    #' k: クラスタの数を指定して分割
    #' h: クラスタの高さを指定して分割
  #+end_src

#+reveal: split
- 視覚化のための関数 (ggplot 系)
  #+begin_src R :eval no :tangle no
    ggdendrogram(data,
                 segments = TRUE, labels = TRUE, leaf_labels = TRUE,
                 rotate = FALSE, theme_dendro = TRUE, ...)
    #' data: stats::hclust(), stats::dendrogram() などの返値
  #+end_src
- 視覚化のための関数 (graphics 系)
  #+begin_src R :eval no :tangle no
    #' stats::plot.hclust() - 系統樹の表示
    plot(x, labels = NULL, hang = 0.1, check = TRUE,
         axes = TRUE, frame.plot = FALSE, ann = TRUE,
         main = "Cluster Dendrogram",
         sub = NULL, xlab = NULL, ylab = "Height", ...)
    #' x: stats::hclust() の返値

    #' stats::rect.hclust() - クラスタの分割表示 (cutreeとほぼ同様)
    rect.hclust(tree, k = NULL, which = NULL, x = NULL, h = NULL,
                border = 2, cluster = NULL)
    #' tree: stats::hclust() の返値
  #+end_src
  
** R : 2次元でのクラスタ表示
:PROPERTIES:
:reveal_background: #fef4f4
:ID:       06758554-01AD-44DD-B4A1-25B987E163B4
:END:
- 関数 ~ggfortify::autoplot()~ (ggplot 系)
  #+begin_src R :eval no :tangle no
    autoplot(object, data = NULL, frame = FALSE,
             scale = 1, x = 1, y = 2,
             variance_percentage = TRUE, ...)
    #' object: stats::prcomp() などの返値
    #' data: 描画に必要な追加データ
    #' frame: クラスタごと(colourなどで指定)に凸包または楕円を描画
    #' 詳細は '?ggfortify::autoplot.pca_common()/ggbiplot()'を参照
  #+end_src
  - クラスタの分割には関数 cutree() を利用する
  - 2次元の散布図の作成には主成分分析などを利用する
#+reveal: split
- 関数 ~cluster::clusplot()~ (graphics 系)
  #+begin_src R :eval no :tangle no
    clusplot(x, clus, diss = FALSE, stand = FALSE,
             lines = 2, shade = FALSE, color = FALSE,
             labels= 0, plotchar = TRUE,
             col.p = "dark green", col.txt = col.p, col.clus = 5，...)
    #' x: データフレーム
    #' clus: クラスタ分割
    #' stand: 正規化の有無
    #' lines: クラスタ間の繋がりの表示 (0:無，1:外，2:中心)
    #' shade: 網掛けの有無
    #' labels: ラベルの表示 (0:無，2:データとクラスタ, 3:データ, 4:クラスタ, など)
    #' col.p/txt/clue: データ点・文字・クラスタの色指定
    #' 詳細は '?cluster::clusplot.default()' を参照
  #+end_src

# - 関数 ~ggfortify::autoplot()~ 
#   #+begin_src R :eval no :tangle no
#     autoplot(object, data = NULL, colour = "cluster", ...)
#     #' object: stats::kmeans(), cluster::pam() などの返値
#     #' data: クラスタリングに用いたデータ (kmeansの場合に必要)
#     #' 詳細は '?ggfortify::autoplot.kmeans()' を参照
#   #+end_src


** COMMENT 演習: 階層的クラスタリング
:PROPERTIES:
:reveal_background: #EEEEFF
:END:
- [[./code/11-hclust.r][11-hclust.r]] を確認してみよう

** 練習問題
:PROPERTIES:
:reveal_background: #fef4f4
:ID:       745A8CD2-BAA4-4F94-8DF0-968E33E8D1CE
:END:
- 都道府県別の社会生活統計指標を用いて以下の分析を行いなさい
  - 平均0，分散1に正規化したデータのユークリッド距離を用いて，
    群平均法による階層的クラスタリングを行いなさい
  - クラスタ数を5つとして分割を行いなさい
** COMMENT 解答例
#+begin_src R :exports none
  #' ---------------------------------------------------------------------------
  #' @practice 階層的クラスタリング
#+end_src
#+begin_src R :eval no :exports none
  #' クラスタリングの実行
  #' 正規化してユークリッド距離を測る
  js_dist <- js_df |> scale() |> dist() # 'dist(scale(js_df))' でも良い
  js_hclust <- js_dist |>
    hclust(method = "average") # 群平均法
  js_hclust |> as.dendrogram() |>  
    ggdendrogram(rotate = FALSE, # 横向きにしない
                 theme_dendro = FALSE) + # 'TRUE'とすれば無地
    labs(title = "Euclidean + Average",
         x = "Prefecture", y = "Height") +
    theme(axis.text.y = element_text(size = 9))
  #' 少数のクラスタに分割してみる
  k <- 5 # 分割数を指定
  js_clust <- cutree(js_hclust, k = k) # デンドログラムを分割
  js_pref <- rownames(js_df) # 県名の取得
  for(i in 1:k){
    cat("=== cluster",i,"===\n")
    print(js_pref[js_clust==i])
  }
  #' @notes
  #' 関数 stats::hclust では base R の関数 plot を利用して
  #' 下記のような方法で簡便にクラスタの分割を表示できる
  #' ggplot で同様なグラフを描く方法は後述
  plot(js_hclust,
       hang = -1, # ラベルを揃えて表示
       cex = 0.8, # 文字のサイズを調整
       sub = "", xlab = "", main = "")
  rect.hclust(js_hclust, k = k, border = "orange") 

  #' 主成分分析を併用して表示
  js_df |>
    prcomp() |> # 主成分分析
    autoplot(data = tibble(cluster = factor(js_clust)),
             colour = 'cluster',
             ## 主成分分析の図をクラスタ毎に色分けするためのデータを追加
             frame = TRUE, # クラスタ毎に枠を付ける
             frame.type = "convex", # 凸包 "convex"・楕円 "norm,t" が指定できる
             label = TRUE, # ラベルを付加
             label.repel = TRUE, # 重なりを回避(ラベルが消える場合もあるので注意)
             label.size = 3, # ラベルの大きさ
             label.show.legend = FALSE) # 凡例の中のアルファベットを除く

  #' 最大クラスタを再評価
  table(js_clust) # 最大を確認
  m <- which.max(table(js_clust)) # 最大クラスタの番号を取り出す
  js_df_sub <- js_df[js_clust==m,]
  js_hclust_sub <- js_df_sub |>
    scale() |> dist() |> hclust(method = "average") 
  js_hclust_sub |> as.dendrogram() |>  
    ggdendrogram(rotate = FALSE, theme_dendro = FALSE) +
    labs(title = "euclidean + average",
         x = "prefecture", y = "distance") +
    theme(axis.text.y = element_text(size = 9))
  js_clust_sub <- cutree(js_hclust_sub, k = 4) # 最大クラスタをさらに分割
  js_df_sub |>
    prcomp() |> # 主成分分析
    autoplot(data = tibble(cluster = factor(js_clust_sub)),
             colour = 'cluster',
             frame = TRUE, 
             frame.type = "convex", 
             label = TRUE,
             label.repel = TRUE,
             label.size = 3,
             label.show.legend = FALSE)
#+end_src
#+begin_src R :exports none
  #' ---------------------------------------------------------------------------
#+end_src

** R : ~package::cluster~ の利用 
:PROPERTIES:
:reveal_background: #fef4f4
:ID:       2E0591D8-A5AC-4640-A560-8F95B9978D92
:END:
- 関数 ~cluster::agnes()~ 
  #+begin_src R :eval no :tangle no
    agnes(x, diss = inherits(x, "dist"), metric = "euclidean",
          stand = FALSE, method = "average", par.method,
          keep.diss = n < 100, keep.data = !diss, trace.lev = 0)
    #' x: データフレーム，または距離行列
    #' metric: 距離 (標準はユークリッド距離，他は 'manhattan' など)
    #' stand: 正規化(平均と絶対偏差の平均による)の有無
    #' method: 分析法 (標準は群平均法，他は 'single', 'complete' など)
  #+end_src
- 視覚化のための補助的な関数 (base R系)
  #+begin_src R :eval no :tangle no
    #' cluster::plot.agnes() - 系統樹および凝集係数の表示
    plot(x, ask = FALSE, which.plots = NULL, main = NULL,
         sub = paste("Agglomerative Coefficient = ",round(x$ac, digits = 2)),
         adj = 0, nmax.lab = 35, max.strlen = 5, xax.pretty = TRUE, ...)
    #' x: cluster::agnes() の返値
    #' which.plots: 1 - banner plot, 2 - dendrogram
  #+end_src
#  - 関数 ~stats::cutree()~, ~stats::rect.hclust()~ も利用可能

** データセットの準備
:PROPERTIES:
:reveal_background: #fef4f4
:END:
- Webアンケート (都道府県別好きなおむすびの具)
  - 「ごはんを食べよう国民運動推進協議会」(平成30年解散) \\
    (閉鎖) http://www.gohan.gr.jp/result/09/anketo09.html
  - データ https://noboru-murata.github.io/multivariate-analysis/data/omusubi.csv

#+reveal: split
- アンケート概要 (Q2の結果を利用)
  #+begin_example
  【応募期間】 2009年1月4日～2009年2月28日
  【応募方法】 インターネット、携帯ウェブ
  【内　　容】
   Q1. おむすびを最近１週間に、何個食べましたか？
       そのうち市販のおむすびは何個でしたか？
   Q2. おむすびの具では何が一番好きですか？
       A.梅 B.鮭 C.昆布 D.かつお E.明太子 F.たらこ Ｇ.ツナ H.その他
   Q3. おむすびのことをあなたはなんと呼んでいますか？
       A.おにぎり B.おむすび C.その他
   Q4. おむすびといえば、どういう形ですか？
       A.三角形 B.丸形 C.俵形 D.その他
  【回答者数】
   男性     9,702人     32.0%
   女性    20,616人     68.0%
   総数    30,318人    100.0%
  #+end_example

** 練習問題
:PROPERTIES:
:reveal_background: #fef4f4
:ID:       126BE363-3942-4D86-B307-3A95240D3AAF
:END:
- データ `omusubi.csv` を用いて以下の分析を行いなさい．
  #+begin_src R :eval no :tangle no
    #' データの読み込み 
    om_data <- read_csv(file = "data/omusubi.csv")
    om_df <- om_data |> column_to_rownames(var = "prefecture")
  #+end_src
  - Hellinger距離を用いて距離行列を作成しなさい
    #+begin_quote
    \(\boldsymbol{p},\boldsymbol{q}\)
    を確率ベクトルとして
    定義される確率分布の間の距離
    \begin{equation}
      d_{hel}(\boldsymbol{p},\boldsymbol{q})
      =
      \frac{1}{\sqrt{2}}d_{euc}(\sqrt{\boldsymbol{p}},\sqrt{\boldsymbol{q}})
    \end{equation}
    #+end_quote
  - 群平均法による階層的クラスタリングを行いなさい
  - クラスタ数を定めて2次元でのクラスタ表示を作成しなさい
** COMMENT 解答例
#+begin_src R :exports none
  #' ---------------------------------------------------------------------------
  #' @practice 階層的クラスタリング 
#+end_src
#+begin_src R :eval no :exports none
  #' データの読み込み("omusubi.csv"を用いる)
  om_data <- bind_cols( # 日本語表記・地方の情報を追加
    read_csv(file = "data/omusubi.csv"),
    read_csv(file = "data/prefecture.csv"))
  #' 距離計算用のデータフレーム
  om_df <- om_data |> 
    select(ume:etc,jp) |>
    set_names(c("梅","鮭","昆布","鰹","明太子","鱈子","ツナ","その他","県名")) |>
    column_to_rownames(var = "県名")
  #' 日本語表示のための設定
  if(Sys.info()["sysname"] == "Darwin") { # MacOSか調べて日本語フォントを指定
    theme_update(text = element_text(family = "HiraMaruProN-W4"))}
  if(Sys.info()["sysname"] == "Darwin") { # MacOSか調べて日本語フォントを指定
    label_family <- "HiraMaruProN-W4"} else {label_family <- NULL}
  #' データの散布図:
  om_data |>
    select(ume:etc,jp,area_jp) |>
    set_names(c("梅","鮭","昆布","鰹","明太子","鱈子","ツナ","その他","県名","地方")) |>
    ggpairs(columns = 1:8,
            upper = list(continuous = "cor"),
            diag = list(continuous = "barDiag"),
            lower = list(continuous = wrap("points", size = 0.5),
                         mapping = aes(colour = 地方)))
  #' 県別の人気比率:
  om_data |>
    select(ume:etc,jp) |>
    set_names(c("梅","鮭","昆布","鰹","明太子","鱈子","ツナ","その他","県名")) |>
    pivot_longer(-県名) |>
    mutate(県名 = fct_rev(as_factor(県名)),
           name = as_factor(name)) |> # ggplot(aes(x = 県名, y = value)) +
    ggplot(aes(y = 県名, x = value)) +
    geom_bar(aes(fill = name),
             stat = "identity",
             position = position_stack(reverse=TRUE)) +
    labs(title = "おむすびの具 県別人気アンケート (2009)",
         x = "人気比率", fill = "具材") +
    theme(axis.text.y = element_text(size = 9))

  #' Hellinger距離による階層的クラスタリング
  om_agnes <- om_df |> sqrt() |> agnes()
  #' @notes
  #' 1/2乗してEuclid距離を計算すればHellinger距離に比例した量が得られる
  #' 定数倍まで厳密に計算するのであれば '1/sqrt(2)*daisy(sqrt(om_df/100))'

  #' デンドログラムの表示
  om_agnes |> as.dendrogram() |>  
    ggdendrogram(rotate = TRUE, theme_dendro = FALSE) +
    labs(title = "おむすびの具人気アンケート",
         x = "県名", y = "距離") +
    theme(axis.text.y = element_text(size = 9))
  #' クラスタ数7としてクラスタの表示
  k <- 7
  om_clust <- cutree(om_agnes, k = k)  # クラスタを作成
  om_df |>
    prcomp() |>
    autoplot(data = tibble(cluster = factor(om_clust)),
             colour = 'cluster',
             label = TRUE,
             label.repel = TRUE,
             label.size = 3,
             label.family = label_family,
             label.show.legend = FALSE)
  om_df |>
    prcomp() |>
    autoplot(data = tibble(cluster = factor(om_clust)),
             colour = 'cluster',
             frame = TRUE,
             frame.type = "norm", # 各クラスタを正規分布で近似して楕円を描く
             label = TRUE,
             label.repel = TRUE,
             label.size = 3,
             label.family = label_family,
             label.show.legend = FALSE)
  #' @notes
  #' ggplotでは繁雑となるが下記のような図を描くこともできる
  om_dendr <- dendro_data(om_agnes, type="rectangle") # ggplot用に変換
  om_rect <- left_join(label(om_dendr),
                       tibble(label = rownames(om_df),
                              cluster = om_clust)) |>
    group_by(cluster) |>
    summarize(xmin = min(x)-0.3, xmax = max(x)+0.3)
  om_ymax <- mean(sort(om_agnes$height, decreasing = TRUE)[k-0:1])
  om_agnes |>
    as.dendrogram() |>
    ggdendrogram(rotate = TRUE, theme_dendro = FALSE) +
    labs(title = "クラスタの分割",
         x = "県名", y = "距離") +
    theme(axis.text.x = element_text(size = 9)) +
    geom_rect(data = om_rect,
              aes(xmin = xmin, xmax = xmax, ymin = 0, ymax = om_ymax,
                  fill = as_factor(cluster)),
              alpha = 0.3, show.legend = FALSE)
  #' @notes
  #' 繁雑な処理を関数化するには例えば以下のようにすればよい
  rect_agnes <- function(x, k) {
    rect <- left_join(label(dendro_data(x, type="rectangle")),
                      tibble(label = rownames(x$data),
                             cluster = cutree(x, k = k))) |>
    group_by(cluster) |>
    summarize(xmin = min(x)-0.3, xmax = max(x)+0.3) |>
    mutate(ymax = mean(sort(x$height, decreasing = TRUE)[k-0:1]))
  }
  om_agnes |>
    as.dendrogram() |>
    ggdendrogram(rotate = TRUE, theme_dendro = FALSE) +
    geom_rect(data = rect_agnes(om_agnes, k = k),
              aes(xmin = xmin, xmax = xmax, ymin = 0, ymax = ymax,
                  fill = as_factor(cluster)),
              alpha = 0.3, show.legend = FALSE) +
    labs(title = "クラスタの分割",
         x = "県名", y = "距離") +
    theme(axis.text.x = element_text(size = 9)) 
  #' @notes
  #' 'package::cluster' には graphics 系の描画関数が含まれている
  #' 例えば上記と同様なグラフは以下のようにして書ける
  if(Sys.info()["sysname"]=="Darwin"){par(family="HiraMaruProN-W4")}
  plot(om_agnes, which.plot = 2, cex = 0.8, # 関数plot.agnes()を使う場合
       main = "Dendrogram of Omusubi Data")
  plot(as.dendrogram(om_agnes), # 関数plot.dendrogram()を使う場合
       main = "Dendrogram of Omusubi Data")
  rect.hclust(om_agnes, k = k, border = (1:k)+1)
  clusplot(x = om_df,
           clus = cutree(om_agnes, k = k),
           labels = 2,
           col.p = "green", col.txt = "blue", col.clus = "orange", cex = 0.8,
           main = "Cluster of Omusubi Data")
#+end_src
#+begin_src R :exports none
  #' ---------------------------------------------------------------------------
#+end_src


* COMMENT 解析事例
# 早稲田大学
** 都道府県別の社会生活統計指標
:PROPERTIES:
:ID:       18026234-D183-45BA-96C2-F7A94C09F8EC
:END:
- 各データを正規化
  #+begin_example
  Forest : 森林面積割合 (%) 2014年
  Agri   : 就業者１人当たり農業産出額(販売農家）(万円) 2014年
  Ratio  : 全国総人口に占める人口割合 (%) 2015年
  Land   : 土地生産性（耕地面積１ヘクタール当たり）(万円) 2014年
  Goods  : 商業年間商品販売額［卸売業＋小売業］（事業所当たり）(百万円) 2013年
  #+end_example
- 分析方法 : Euclid 距離 + 群平均法

#+reveal: split
#+begin_src R :file figs/10_jsclst.png :exports results :results graphics :tangle yes
  #' 階層的クラスタリングの実行:
  js_hclust <- js_data |>
    select(2:6,jp) |>
    column_to_rownames(var = "jp") |>
    agnes(stand = TRUE)
  js_hclust |>
    as.dendrogram() |>
    ggdendrogram(rotate = FALSE, theme_dendro = FALSE) +
    labs(title = "Euclid 距離 + 群平均法",
         x = "県名", y = "距離") +
    theme(axis.text.x = element_text(size = 9))
#+end_src
#+caption: 社会生活統計指標のクラスタ分析 (デンドログラム)
#+name: fig:10_jsclst
#+attr_html: height 100%
#+attr_latex: :width 0.6\linewidth
[[file:figs/10_jsclst.png]]


#+reveal: split
#+begin_src R :file figs/10_jscut.png :exports results :results graphics :tangle yes
  k <- 5 # 分割数を指定
  js_clust <- cutree(js_hclust, k = k)  # クラスタを作成
  js_dendr <- dendro_data(js_hclust, type="rectangle") # ggplot用に変換
  js_rect <- left_join(label(js_dendr),
                       tibble(label = js_data[["jp"]],
                              cluster = js_clust)) |>
    group_by(cluster) |>
    summarize(xmin = min(x)-0.3, xmax = max(x)+0.3)
  js_ymax <- mean(sort(js_hclust$height, decreasing = TRUE)[k-0:1])
  js_hclust |>
    as.dendrogram() |>
    ggdendrogram(rotate = FALSE, theme_dendro = FALSE) +
    labs(title = "クラスタの分割",
         x = "県名", y = "距離") +
    theme(axis.text.x = element_text(size = 9)) +
    geom_rect(data = js_rect,
              aes(xmin = xmin, xmax = xmax, ymin = 0, ymax = js_ymax,
                  fill = as_factor(cluster)),
              alpha = 0.3, show.legend = FALSE)
  ## segment(js_dendr) |>
  ##   ggplot() +
  ##   geom_segment(aes(x = x, y = y, xend = xend, yend = yend)) +
  ##   geom_text(data = label(js_dendr),
  ##             aes(x, y, label = label, hjust = 0, color = js_clust),
  ##             size = 3)
  #+end_src
#+caption: 5分割の例
#+name: fig:10_jscut
#+attr_html: height 100%
#+attr_latex: :width 0.6\linewidth
[[file:figs/10_jscut.png]]

** COMMENT 5クラスタに分割する例
#+reveal: split
- 5クラスタに分割
  #+begin_src R :exports results :tangle yes
    ## 結果の確認 (各クラスタ内の県名を表示)
    js_clst <- cutree(js_est, k=k) # デンドログラムを分割
    js_pref <- rownames(js_data) # 県名の取得
    for(i in 1:k) {
      cat("=== cluster ",i,"===\n")
      print(js_pref[js_clst==i])
    }
  #+end_src

** 都道府県別好きなおむすびの具
:PROPERTIES:
:ID:       D18A17B8-52C8-4157-9CA0-846C0D82A92F
:END:
- Webアンケート
  - 「ごはんを食べよう国民運動推進協議会」(平成30年解散) \\
    http://www.gohan.gr.jp/result/09/anketo09.html (閉鎖) 
  - データ https://noboru-murata.github.io/multivariate-analysis/data/omusubi.csv

#+reveal: split
- アンケート概要 (Q2の結果を利用)
  #+begin_example
  【応募期間】 2009年1月4日～2009年2月28日
  【応募方法】 インターネット、携帯ウェブ
  【内　　容】
   Q1. おむすびを最近１週間に、何個食べましたか？
       そのうち市販のおむすびは何個でしたか？
   Q2. おむすびの具では何が一番好きですか？
       A.梅 B.鮭 C.昆布 D.かつお E.明太子 F.たらこ Ｇ.ツナ H.その他
   Q3. おむすびのことをあなたはなんと呼んでいますか？
       A.おにぎり B.おむすび C.その他
   Q4. おむすびといえば、どういう形ですか？
       A.三角形 B.丸形 C.俵形 D.その他
  【回答者数】
   男性     9,702人     32.0%
   女性    20,616人     68.0%
   総数    30,318人    100.0%
  #+end_example
- 分析方法 : Hellinger距離(確率分布の距離) + 群平均法

#+reveal: split
#+begin_src R :exports none
  #' データの読み込み("omusubi.csv"を用いる)
  om_data <- bind_cols(
    read_csv(file="data/omusubi.csv"),
    read_csv(file="data/prefecture.csv"))
#+end_src

#+begin_src R :file figs/10_ombar.png :exports results :results graphics
  #' 県別の人気比率:
  om_data |>
    select(ume:etc,jp) |>
    set_names(c("梅","鮭","昆布","鰹","明太子","鱈子","ツナ","その他","県名")) |>
    pivot_longer(-県名) |>
    mutate(県名 = fct_rev(as_factor(県名)),
           name = as_factor(name)) |> # ggplot(aes(x = 県名, y = value)) +
    ggplot(aes(y = 県名, x = value)) +
    geom_bar(aes(fill = name),
             stat = "identity",
             position = position_stack(reverse=TRUE)) +
    labs(title = "おむすびの具 県別人気アンケート (2009)",
         x = "人気比率", fill = "具材") +
    theme(legend.position = "top",
          axis.text.y = element_text(size = 9))
#+end_src

#+caption: データの概要
#+name: fig:10_ombar
#+attr_html: height 100%
#+attr_latex: :width 0.6\linewidth
[[file:figs/10_ombar.png]]

#+reveal: split
#+begin_src R :file figs/10_ompairs.png :exports results :results graphics
  #' データの散布図:
  om_data |>
    select(ume:etc,jp,area_jp) |>
    set_names(c("梅","鮭","昆布","鰹","明太子","鱈子","ツナ","その他","県名","地方")) |>
    GGally::ggpairs(columns = 1:8,
                    upper = list(continuous = "cor"),
                    diag = list(continuous = "barDiag"),
                    lower = list(continuous = wrap("points", size = 0.5),
                                 ## wrap("smooth", se = FALSE, size = 0.5),
                                 mapping = aes(colour = 地方)))
#+end_src

#+caption: データの散布図
#+name: fig:10_ompairs
#+attr_html: height 100%
#+attr_latex: :width 0.6\linewidth
[[file:figs/10_ompairs.png]]

#+reveal: split
#+begin_src R :file figs/10_omclst.png :exports results :results graphics
  #' 距離計算
  om_data |>
    select(ume:etc,jp) |>
    set_names(c("梅","鮭","昆布","鰹","明太子","鱈子","ツナ","その他","県名")) |>
    column_to_rownames(var = "県名") |>
    sqrt() |>
    daisy() |>
    agnes() |>
    as.dendrogram() |>
    ggdendrogram(rotate = TRUE, theme_dendro = FALSE) +
    labs(title = "おむすびの具人気アンケートによるクラスタ分析",
         x = "県名", y = "距離") +
    theme(axis.text.y = element_text(size = 9))
#+end_src

#+caption: デンドログラム
#+name: fig:10_omclst
#+attr_html: height 100%
#+attr_latex: :width 0.6\linewidth
[[file:figs/10_omclst.png]]
   

* 次回の予定
  - 第1回 : 基本的な考え方と階層的方法
  - *第2回 : 非階層的方法と分析の評価*


* Footnotes
* COMMENT ローカル変数
# Local Variables:
# org-latex-listings: minted
# End:
